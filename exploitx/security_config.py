import os
import re
import hashlib
import secrets
from datetime import datetime, timedelta
from flask import request, session, abort
from werkzeug.security import generate_password_hash
import bleach
from email_validator import validate_email, EmailNotValidError

class SecurityConfig:
    """Security configuration and utilities for the ExploitX application"""
    
    # Password policy
    MIN_PASSWORD_LENGTH = 12
    PASSWORD_REQUIREMENTS = {
        'uppercase': True,
        'lowercase': True,
        'numbers': True,
        'special_chars': True
    }
    
    # Rate limiting
    LOGIN_ATTEMPTS_LIMIT = 5
    LOGIN_ATTEMPTS_WINDOW = 300  # 5 minutes
    API_RATE_LIMIT = "100 per minute"
    
    # Session security
    SESSION_TIMEOUT = 3600  # 1 hour
    PERMANENT_SESSION_LIFETIME = timedelta(hours=2)
    
    # Content Security Policy
    CSP_POLICY = {
        'default-src': ["'self'"],
        'script-src': ["'self'", "'unsafe-inline'"],
        'style-src': ["'self'", "'unsafe-inline'"],
        'img-src': ["'self'", "data:", "https:"],
        'font-src': ["'self'"],
        'connect-src': ["'self'"],
        'frame-ancestors': ["'none'"],
        'base-uri': ["'self'"],
        'form-action': ["'self'"]
    }
    
    # Security headers
    SECURITY_HEADERS = {
        'X-Content-Type-Options': 'nosniff',
        'X-Frame-Options': 'DENY',
        'X-XSS-Protection': '1; mode=block',
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
        'Referrer-Policy': 'strict-origin-when-cross-origin',
        'Permissions-Policy': 'geolocation=(), microphone=(), camera=()'
    }
    
    @staticmethod
    def validate_password(password):
        """Validate password against security policy"""
        if len(password) < SecurityConfig.MIN_PASSWORD_LENGTH:
            return False, f"Password must be at least {SecurityConfig.MIN_PASSWORD_LENGTH} characters long"
        
        if SecurityConfig.PASSWORD_REQUIREMENTS['uppercase'] and not re.search(r'[A-Z]', password):
            return False, "Password must contain at least one uppercase letter"
        
        if SecurityConfig.PASSWORD_REQUIREMENTS['lowercase'] and not re.search(r'[a-z]', password):
            return False, "Password must contain at least one lowercase letter"
        
        if SecurityConfig.PASSWORD_REQUIREMENTS['numbers'] and not re.search(r'\d', password):
            return False, "Password must contain at least one number"
        
        if SecurityConfig.PASSWORD_REQUIREMENTS['special_chars'] and not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
            return False, "Password must contain at least one special character"
        
        return True, "Password meets requirements"
    
    @staticmethod
    def sanitize_input(text, allowed_tags=None, allowed_attributes=None):
        """Sanitize user input to prevent XSS"""
        if not text:
            return ""
        
        # Default allowed tags and attributes for different contexts
        if allowed_tags is None:
            allowed_tags = ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li']
        
        if allowed_attributes is None:
            allowed_attributes = {}
        
        return bleach.clean(text, tags=allowed_tags, attributes=allowed_attributes, strip=True)
    
    @staticmethod
    def validate_email(email):
        """Validate email format"""
        try:
            validate_email(email)
            return True, "Valid email"
        except EmailNotValidError as e:
            return False, str(e)
    
    @staticmethod
    def generate_secure_token():
        """Generate a secure random token"""
        return secrets.token_urlsafe(32)
    
    @staticmethod
    def hash_sensitive_data(data):
        """Hash sensitive data for logging"""
        return hashlib.sha256(data.encode()).hexdigest()[:16]
    
    @staticmethod
    def check_brute_force_attempts(identifier, max_attempts=LOGIN_ATTEMPTS_LIMIT):
        """Check if too many login attempts have been made"""
        attempts_key = f"login_attempts_{identifier}"
        attempts = session.get(attempts_key, 0)
        return attempts >= max_attempts
    
    @staticmethod
    def record_login_attempt(identifier, success=False):
        """Record a login attempt"""
        attempts_key = f"login_attempts_{identifier}"
        if success:
            session.pop(attempts_key, None)
        else:
            attempts = session.get(attempts_key, 0) + 1
            session[attempts_key] = attempts
            session[f"login_attempts_time_{identifier}"] = datetime.utcnow().timestamp()
    
    @staticmethod
    def should_block_login(identifier):
        """Check if login should be blocked due to too many attempts"""
        attempts_key = f"login_attempts_{identifier}"
        time_key = f"login_attempts_time_{identifier}"
        
        attempts = session.get(attempts_key, 0)
        if attempts >= SecurityConfig.LOGIN_ATTEMPTS_LIMIT:
            last_attempt_time = session.get(time_key, 0)
            if datetime.utcnow().timestamp() - last_attempt_time < SecurityConfig.LOGIN_ATTEMPTS_WINDOW:
                return True
            else:
                # Reset attempts after timeout
                session.pop(attempts_key, None)
                session.pop(time_key, None)
        return False
    
    @staticmethod
    def validate_file_upload(filename, allowed_extensions=None, max_size=5*1024*1024):
        """Validate file uploads"""
        if allowed_extensions is None:
            allowed_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt'}
        
        if not filename:
            return False, "No file selected"
        
        # Check file extension
        file_ext = os.path.splitext(filename.lower())[1]
        if file_ext not in allowed_extensions:
            return False, f"File type not allowed. Allowed types: {', '.join(allowed_extensions)}"
        
        return True, "File validation passed"
    
    @staticmethod
    def sanitize_filename(filename):
        """Sanitize filename to prevent path traversal"""
        # Remove any path components
        filename = os.path.basename(filename)
        # Remove any potentially dangerous characters
        filename = re.sub(r'[^\w\-_\.]', '', filename)
        # Add timestamp to prevent conflicts
        timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
        name, ext = os.path.splitext(filename)
        return f"{name}_{timestamp}{ext}"
    
    @staticmethod
    def validate_input_length(text, max_length=1000, min_length=1):
        """Validate input length"""
        if not text:
            return False, "Input cannot be empty"
        
        if len(text) < min_length:
            return False, f"Input must be at least {min_length} characters long"
        
        if len(text) > max_length:
            return False, f"Input cannot exceed {max_length} characters"
        
        return True, "Input length is valid"
    
    @staticmethod
    def log_security_event(event_type, details, user_id=None, ip_address=None):
        """Log security events"""
        if ip_address is None:
            ip_address = request.remote_addr
        
        log_entry = {
            'timestamp': datetime.utcnow().isoformat(),
            'event_type': event_type,
            'details': details,
            'user_id': user_id,
            'ip_address': ip_address,
            'user_agent': request.headers.get('User-Agent', 'Unknown')
        }
        
        # In production, this should be logged to a secure logging service
        print(f"SECURITY EVENT: {log_entry}")
        
        return log_entry

def require_admin(f):
    """Decorator to require admin privileges"""
    from functools import wraps
    from flask import abort, flash, redirect, url_for
    from flask_login import current_user
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Please log in to access this page.', 'error')
            return redirect(url_for('admin_login'))
        
        if not current_user.is_admin and not current_user.is_super_admin:
            SecurityConfig.log_security_event('unauthorized_access', f'Attempted to access {request.endpoint}', current_user.id)
            flash('Access denied. Admin privileges required.', 'error')
            return redirect(url_for('index'))
        
        return f(*args, **kwargs)
    return decorated_function

def require_super_admin(f):
    """Decorator to require super admin privileges"""
    from functools import wraps
    from flask import abort, flash, redirect, url_for
    from flask_login import current_user
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            flash('Please log in to access this page.', 'error')
            return redirect(url_for('admin_login'))
        
        if not current_user.is_super_admin:
            SecurityConfig.log_security_event('unauthorized_access', f'Attempted to access super admin function {request.endpoint}', current_user.id)
            flash('Access denied. Super admin privileges required.', 'error')
            return redirect(url_for('admin_dashboard'))
        
        return f(*args, **kwargs)
    return decorated_function 